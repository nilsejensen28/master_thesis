\setchapterpreamble[u]{\margintoc}
\chapter{Binary Search and \EOPL}

The aim of this chapter is to show that one can reduce binary search onto \EOPL.
In order to do this, we will introduce a new total search problem which we call \textsc{Sink of Line} (\SOL), which we think encapsulates the problems that can
be solved using binary search.
Finally we will show a reduction from \SOL\ onto to \EOPL.

\section{Introducing \SOL}

The \textsc{Sink of Line} problem is a total search problem that can be described as follows:
\problem{Sink of Line (\SOL)}
{A binary circuit $S : [2^n - 1] \rightarrow \directions $}
{A point $x$ such that either:
\begin{itemize}
    \item $S(x) = \bullet$ (sink)
    \item $S(x) = \rarr$ and $S(x+1) = \larr$ (violation of acyclicity)
    \item $S(0) = \larr$ or $S(2^n - 1) = \rarr $ (violation of boundary conditions)
\end{itemize}
}
\marginnote[-30mm]{The points can be thought of a beeing on a line and each point either pointing to the left, to the right or beeing a fixpoint.}

The \SOL\ problem is a total search problem, it can be shown that if there is no violation, there must be a sink.
This sink can be found using binary search as we will describe below.
Before we do this we want to introduce some notation in order which will help us with the reduction from \SOL\ to \EOPL.
We define the sets $\calB_i$ for $i \in \{0, \dots, n\}$ as follows:
\begin{align*}
    \calB_i = \{ b_{i, k} = \winterval{k \cdot 2^{n-i}}{(k+1) \cdot 2^{n-i} - 1} | k \in \{0, \dots 2^i - 1\} \}
\end{align*}
\marginnote[-10mm]{We use the notation $\winterval{a}{b}$ to denote the set of whole numbers $\{a, a+1, \dots, b\}$.}
The set $\calB_i$ is a partition of the set $[2^n - 1]$ into $2^i$ intervals of length $2^{n-i}$.

In general binary search over $[2^n - 1]$ can be described as follows finding a sequence of intervals $b_{0, k_0}, b_{1, k_1}, \dots, b_{n, k_{n}}$ such
that $b_{i+1, k_{i+1}} \subset b_{i, k_i}$ for all $i \in \{0, \dots, n-1\}$.
And the point of interest $x^*$ is in the interval $b_{i, k_i}$ for all $i$.
Because $b_{n, k_n}$ is a single point, we can find $x^*$ is the point in $b_{n, k_n}$.

Now let us discuss how one can use binary search to solve \SOL.
The full algorithm is given in \cref{alg:bin_search}.
This really is just a classical binary search algorithm as introduced for example in \sidecite{knuth_art_1997}, but we want to discuss why every solution we
find, is in deed a solution to \SOL.
\begin{claim}
    Every output of \textsc{BinarySearch} is a solution to \SOL. This shows that \SOL\ is a total search problem.
\end{claim}
\begin{proof}
    In order to do this we will prove that every return statement made in \cref{alg:bin_search} is a solution to \SOL.
    TODO
\end{proof}

\begin{algorithm}[!hbt]
    \caption{Binary Search for \SOL}\label{alg:bin_search}

    \KwIn{A binary circuit $S : \winterval{k \cdot 2^j}{(k+1) \cdot 2^{j+1} - 1} \rightarrow \directions$}
    \KwOut{A solution $x$ to \SOL:}

    \emph{Initialize variables for left and right boundary}\\
    $a \longleftarrow k \cdot 2^j$ \\
    $b \longleftarrow (k+1) \cdot 2^{j+1} - 1$\\

    \emph{Check if we have a single point} \\
    \If{$a=b$}{
        \Return $a$ \label{alg:bin_search:return_1}
    }
    \emph{Check boundary conditions} \\
    \If{$S(a) = \larr$}{
        \Return $\max{0, a-1}$
    }
    \If{$S(b) = \rarr$}{
        \Return $b$
    }
    \emph{Recurse (binary search)} \\
    $m \longleftarrow (2k + 1) \cdot 2^j$ \\
    \If{$S(m) = \bullet$}{
        \Return $m$
    }
    \If{$S(m) = \rarr$}{
        \Return \textsc{BinarySearch}$(S, \winterval{2k+1 \cdot 2^{j-1}}{(2k+2) \cdot 2^{j-1}- 1})$
    }
    \If{$S(m) = \larr$}{
        \Return \textsc{BinarySearch}$(S, \winterval{2k \cdot 2^{j-1}}{(2k+1) \cdot 2^{j-1} - 1})$
    }
\end{algorithm}

\section{Reduction of \SOL\ onto \EOPL}[Reducing \SOL\ to \EOPL]

\begin{theorem}[$\SOL \subset \EOPL$]
    \textsc{Sink of Line} can be reduced in \poly(n) time onto an instance of \textsc{End of Potential Line} such that a solution of the \textsc{End of
        Potential Line} instance is also a solution of the \textsc{Sink of Line} instance.
\end{theorem}
\begin{proof}
    Before we dive into the formal proof we give an informal description of the construction we will use.
    The idea of the reduction is to find a solution $x^*$ of the \SOL\ instance using binary search.
    Then for every $x \in [2^n - 1]$, we can look at where $x$ diverges from $x^*$ in the binary search tree.
    We then construct an \EOPL\ instance which first passes through all vertices that diverge in the first decision, then through all those that diverge in the
    second decision, and so on.
    The final node of the instance (and the only sink) is $x^*$.
    For clarity we provide the reader with Figure XX, which represents the different steps of the reduction in the case $n=3$, and might be useful to refer to
    during the proof.

    Formally we are given a circuit $S: [2^n -1] \rightarrow \directions$, we look to construct 3 new circuits $\BarS, \BarP, \BarV : [2^n - 1] \rightarrow
        [2^n - 1]$, which will describe an instance of \EOPL\ as follows:
    First we perform binary search as described in \cref{alg:bin_search} to find a solution $x^*$ to the \SOL\ instance given by $S$.
    This solution $x^*$ and the associated binary search is associated to a unique sequence of sets:
    \begin{align*}
        \{x^*\} = B_{n, k_n} \subset B_{n-1, k_{n-1}} \subset \dots \subset B_{0, k_0} = [2^n - 1]
    \end{align*}
    where each $B_{i, k_i}$ is a set of the partition $\calB_i$.
    \marginnote{We note that actually constructing the sets $B_{i, k_i}$, is not necessary for constructing the reduction, they will simply make the argument
        of the proof more clear.}
    Notice that this sequence is completely described by the binary encoding of $x^*$, indeed $B_{i, k_i}$ are the $x$ for which the first $i$ digits of the
    binary repretation are the same as $x^*$'s.
    Also computing $x^*$ can be done in polynomial time, more precisely in $\BigO{\log(2^n)}=\BigO{n}$ time.

    Now we can construct a partion of $[2^n-1]$ as follows. For every $i \in \{0, \dots, n-1\}$ define:
    \begin{align*}
        A_i = B_{i, k_{i}} \setminus B_{i+1, k_{i+1}}
    \end{align*}
    And set $A_n = \{x^*\}$. Then the $(A_i)_i$ form a partition of $[2^n -1]$.
    We give an example of such a partition in Fig XX.
    Notice once again, that the $A_i$'s can be described very easily using the binary representation of $x^*$. $A_i$ is simply the set of all $x$ who have the
    same $i$ binary digits as $x^*$ and whos $i+1$-th digit differs.
    Because we have a partition we can define the \emph{level} of $x$, $\lev(x)$ as the unique $i$ such that $x \in A_i$.
    This can be seen as the number of digits of $x$ and $x^*$ that are identical from the left.
    In particular this means that the level of a vertex can be evaluated by a boolean circuit of depth at most $n+1$.

    We also define two helper functions $f, l : \{0, \dots, n\} \rightarrow [2^n -1]$ which are meant to be understood as the boundaries of $A_i$.
    \marginnote[-10mm]{Once again these functions are mainly for notational convenience. We can in particular also write $A_i = \winterval{f(i)}{g(i)}$.}
    Also notice that these can be explicitly defined using boolean circuits:
    \marginnote[5mm]{Here we use the notation ${x[i:j] = x[i] \dots x[j]}$, the $i$-th through $j$-th digits, $\overline{x}$ is the negation of $x$ and
        $\oplus$ is string concatenantion.}
    \begin{align*}
        f(i) & = x^*[1:i] \oplus \overline{x^*[i+1]} \oplus 0^{n-i} \\
        g(i) & = x^*[1:i] \oplus \overline{x^*[i+1]} \oplus 1^{n-i}
    \end{align*}
    Now we are ready to define our circuits. The idea of the construction is to construct a potential line which starts by traversing $A_0$
    lexicographically, then $A_1$ lexicographically and so on.
    Hence we define $\BarS$ accordingly:
    \begin{align*}
        \BarS(x) = \begin{cases}
                       x+1          & \text{if } x+1 \in [2^n-1] \text{ and } \lev(x) = \lev(x+1) \\
                       x            & \text{if } x = f(n)                                         \\
                       f(\lev(x+1)) & \text{otherwise}
                   \end{cases}
    \end{align*}
    We define $\BarP$ annogously:
    \begin{align*}
        \BarP(x) = \begin{cases}
                       x+1          & \text{if } x-1 \in [2^n-1] \text{ and } \lev(x) = \lev(x-1) \\
                       x            & \text{if } x = f(0)                                         \\
                       g(\lev(x-1)) & \text{otherwise}
                   \end{cases}
    \end{align*}
    Finally we need to define a potential $\BarV$:
    \begin{align*}
        \BarV(x) = 1^{\lev(x)} \oplus (x - f(\lev(x)))
    \end{align*}
    An example of this construction can be found in XXX.
    $\BarS, \BarP, \BarV$ can be represented as boolean circuits of depth at most $\BigO{n + \depth(S)}$.
    Together they form an instance of \EOPL\ with source $f(0)$.
\end{proof}