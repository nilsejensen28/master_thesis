\setchapterpreamble[u]{\margintoc}
\chapter{Introduction}

\section{Total Search Problems}

The study of computational complexity is central to computer science, its primary goal is to establish lower bounds on the complexity of various problems. Specifically, complexity theory attempts to prove that certain problems cannot be solved faster than a given time, as a function of the input size. This endeavor has proven to be particularly challenging for many problems where there is a significant gap between the best-known lower bounds and the upper bounds determined by existing algorithms.

A fundamental tool in complexity theory is the concept of reduction, which makes it possible to compare the difficulty of two problems. We say that a problem $P_1$ is reducible to another problem $P_2$ if $P_1$ can be solved efficiently by solving $P_2$\marginnote{Here, \emph{efficiently} generally means in polynomial time. We will define this and related concepts more strictly later.}. This concept underlies the classification of problems into complexity classes-groups of problems that are mutually reducible.

Traditionally, complexity theory has focused on decision problems, which involve determining whether a given object has a given property. Examples include determining whether a graph contains a $k$ clique, or whether a number is prime. These problems typically require a decision about whether an object belongs to a set of objects-a language-defined by a particular property.

However, real-world challenges often extend beyond simple decision making into the realm of search problems. In practical scenarios, the existence of a solution is typically assumed, and the task is not just to verify its existence, but to compute the solution itself. For example, instead of just detecting the presence of a $k$ clique in a graph, one may need to explicitly find this clique or confirm its absence. Similarly, instead of just recognizing a number as prime, one might need to determine its prime factors.

Within this broader category of search problems lies a special subclass known as \emph{total search problems}. These are characterized by the guaranteed existence of a solution, often proved by mathematical theorems. A notable example within this subclass is the problem of identifying a sink in a directed acyclic graph, where the existence of such a sink is guaranteed.

\section{The TFNP landscape}

The class of \TFNP, is the pendant of \NP, in the sence that it is the class of all total search problems, where a solution can be checked for validity in polynomial time. The study of this complexity class has been a active research subject in the last years and has given rise to many interesting results.

TODO: Write some inuition about the subclasses.

\section{The \Tarski\ problem}

The main problem we study in this thesis is the \Tarski\ problem. The name sake of the \Tarski\ problem is \textsc{Tarski's fixed point theorem}, which states that every monotone function on a complete lattice has a fixed point\sidecite{tarski_lattice-theoretical_1955}. The \Tarski\ problem is the problem of finding such a fixed point for a given function $f$ on a complete lattice $L$, or to find a violation of monoticity of this function. By Tarski's theorem, this problem is guaranteed to have a solution, and hence is a total search problem.

\section{Current algorithms for solving \Tarski}

TODO: Write this section.

\section{Location of \Tarski\ in \TFNP}
It is known that the \Tarski\ problem lies in \PPAD\ and in \PLS. A very recent breakthrough has shown that the class $\PPAD \cap \PLS = \EOPL$ \sidecite{goos_further_2022}. This result immediately implies that the \Tarski\ problem is in \EOPL, which in turn means that there must be a reduction from \Tarski\ to \EOPL-complete problems, in particular to the \EndOfPotentialLine\ problem.

\section{Thesis Outline}

TODO: Write this section.