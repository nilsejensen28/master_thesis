\setchapterpreamble[u]{\margintoc}
\chapter{Preliminaries}

The aim of this chapter is to introduce the complexity class \TFNP, and some of its subclasses, in particular \PPAD, \PLS\ and \EOPL.
We will also introduce the \Tarski\ problem.

\section{Total search problems}

The study of complexity classes originally works with so-called \define{decision-problems}, which are the question of deciding on the membership in a set ---
also called a \define{language}.
\marginnote{Notable such problems include deciding on whether a boolean formula can be satified or if a $k$-Clique exist in a given graph.}
Now while these problems are interesting, real world questions or problem often ask for an explicit anwser.
For instance while deciding if a function has a global minimum is a decision problem, we are interrested in actually finding this minimum, which is not a
decision problem.
\marginnote{Even though as we will see it can be transformed into one}
\par
This is where so called \define{search problems} come into play:

\begin{definition}[Search Problem]
    A \define{search problem} is given by a relation $R\subset \binstr \times \binstr$.
    For a given \define{instance} $I\in \binstr$ the computational problem, to find a \define{solution} $s \in \binstr$, that satisfies:
    $(I, s) \in R$ or output ``No'' if no such $s$ exists.
\end{definition}
\marginnote{The ``No'' case can be encoded as some special binary string.}
Now of course we can view these search problems as decision problems by looking at the corresponding decision problem given by the language:
\begin{align*}
    \mathcal{L}_R = \{ I \in \binstr |\ \exists s \in \binstr : (I, s) \in R\}
\end{align*}
We can then ask the classical complexity questions about these search problems, i.e.~whether these search problems are in \P? \NP? whether they are \NP-Hard?
One easily observes that search problems are always at least as hard as just deciding whether a solution exist.
This is because solving a search problem also solves the underlying decision problem.
This leads to the natural question: what if we remove the underlying decision problem?
This can be done by garanteeing that ``No'' is never a solution.
We call these problems where every instance admits a solution \define{total search problems}.
\begin{definition}[Total search problems]
    A \define{total search problem} is a search problem given by a relation $R\subset \binstr \times \binstr$, such that for every given instance $I\in
        \binstr$ there is a solution $s \in \binstr$, that satisfies: $(I, s) \in R$.
\end{definition}
The complexity class \TFNP\ as introduced in \sidecite{papadimitriou_complexity_1994} is simply the class of all total search problems that lie in \NP.
\marginnote{This means that \TFNP\ can be seen as an intermediate class between \P\ and \NP.}
Similarly to decision problem we can also define reduction inside \TFNP.
\begin{definition}[Reduction]
    For two problem $R, S \in \TFNP$, we say that $R$ \define{reduces} (many to one) to $S$ if there exist polynomial time computable functions $f : \binstr
        \rightarrow
        \binstr$ and $g : \binstr \times \binstr \rightarrow \binstr$ such that for $I, s \in \binstr$: if $(f(I), s) \in S$ then $(I, g(I, s)) \in R$.
    This means that if $s$ is a solution to an instance $f(I)$ in $S$, we can compute $g(I, s)$ a solution to an instance $I$ in $R$
\end{definition}
\marginnote[-15mm]{Saying \textit{one can reduce $R$ onto $S$} can be understood as saying \textit{if one can solve $S$ efficiently then I can solve $R$
        efficiently}.}

\section{An excursion into Binary Circuits}[Binary Circuits]

TODO

\section{Subclasses of \TFNP}

Because the existence of complete \FNP-Problems in \TFNP\, would imply $\NP = \coNP$, as described in \sidecite{megiddo_total_1991}.
Because this is a very unexpected outcome we cannot expect to find complete problems in \TFNP.
This means that we should use other tools to study the structure of \TFNP. \par
One of the proposed methods \sidecite{papadimitriou_complexity_1994} is to categorize total search problems with respect to the existence results which allow
them to be \textit{total}. This is what leads to the complexity classes we will discuss next.

\subsection{Polynomial Local Search (\PLS)}[\PLS]

The existence results which gives rise to \PLS\ is ``\textit{every directed acyclic graph has a sink}''.
We can then construct the class \PLS\ by defining it as all problems which reduce to finding the sink of a directed acyclic graph (DAG). \par
Formally we first define the problem \Localopt\ as in \sidecite{johnson_how_1988}:

\problem{Localopt}{Two binary circuits $P, S : [2^n] \rightarrow\ [2^n]$.}{A vertex $v \in [2^n]$ such that $P(S(v)) \geq\ P(v)$.}
\marginnote[-20mm]{$S$ can be seen as a proposed successor, and $P$ as a potential. The goal is to find a local minima $v$ of the potential}

One might ask why this is equivalent to finding the sink of a DAG?
The circuit $S$ defines a directed graph, which might contain cycles.
Only keeping the edge on which the potential decreases (strictly) leads to a DAG, with as sinks exactly the $v$ such that $P(S(v)) \geq\ P(v)$. Now we can
define \PLS :

\begin{definition}[Polynomial Local Search (\PLS)]
    The class \PLS\ is the set of all \TFNP\ problems that reduce to \Localopt.
\end{definition}

\subsection{Polynomial Parity Argument on Directed Graphs (\PPAD)}[\PPAD]

TODO

\subsection{End of Potential Line (\EOPL)}[\EOPL]

TODO

\section{The \Tarski\ Problem}[\Tarski\ Problem]

Next we want to introduce the \Tarski\ Problem.
Before we do this we recall that there is a partial order on the $d$ dimensional latice $[N]^d$, given by $x \leq y$ iff $x_i \leq y_i$ for all $i \in \{1,
    \dots, d\}$.
The name originates from \textsc{Tarski's} fixed point Theorem as introduced in \sidecite{tarski_lattice-theoretical_1955} which we remind the reader of below:

\begin{theorem}[Tarski's fixed point Theorem]
    Let $f : [N]^d \rightarrow [N]^d$ a function on the $d$-dimentional lattice.
    If $f$ is monotonous (with respect to the previously discussed partial order), then $f$ has a fixed point, i.e. there is an $x \in [N]^d$ such that
    $f(x)=x$.
\end{theorem}
\marginnote[-20mm]{This theorem is also known as the Knasterâ€“Tarski theorem in the litterature.}
A proof of this theorem can be found in the previously mentionned work~\cite{tarski_lattice-theoretical_1955}.
Without surprise the \Tarski\ problem as defined in \sidecite{etessami_tarskis_2020}, is now to find such a fixed-point.
Formally we define the problem as follows:
\problem{Tarski}{A boolean circuit $S : [N]^d \rightarrow [N]^d$.}{Either:
\begin{itemize}
    \item An $x \in [N]^d$ such that $S(x)=x$ (fixed point) or
    \item $x, y \in [N]^d$ such that $x \leq y$ and $f(x) \nleq f(y)$ (violation of monoticity).
\end{itemize}
}

This is of course a total search problem, as there will always either be a fixed point, or a point violating monoticity.
We now want to summarize where \Tarski\ lies inside of \TFNP.
It has been shown in~\cite{etessami_tarskis_2020} that \Tarski\ lies in both \PLS\ and $\P^{\PPAD}$.
Previous work~\sidecite{buss_propositional_2012}, showed that many-to-one reductions and Turing-reduction onto \PPAD\ are equivalent.
In particular this means that $\P^{\PPAD} = \PPAD$, and that \Tarski\ also lies in \PPAD.

\section{Structure of \texorpdfstring{$\PLS \cap \PPAD$}{\PLS\ and \PPAD}}[\texorpdfstring{$\PLS \cap \PPAD$}{\PLS\ and \PPAD}]

Now that we have established that \Tarski\ lies inside $\PLS \cap \PPAD$, we want to discuss the structure of $\PLS \cap \PPAD$ and describe recent advances in
the study of this class.