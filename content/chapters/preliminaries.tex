\setchapterpreamble[u]{\margintoc}
\chapter{Preliminaries}

The aim of this chapter is to introduce the complexity class \TFNP, and some of its subclasses, in particular \PPAD, \PLS\ and \EOPL{}.
We will also introduce the \Tarski\ problem.

\section{Total search problems}

The study of complexity classes originally works with so-called \define{decision-problems}, which are the question of deciding on the membership in a set --- also called a \define{language}.
\marginnote{Notable such problems include deciding on whether a boolean formula can be satified or if a $k$-Clique exist in a given graph.}
Now while these problems are interesting, real world questions or problem often ask for an explicit anwser.
For instance while deciding if a function has a global minimum is a decision problem, we are interrested in actually finding this minimum, which is not a decision problem\marginnote{Even though as we will see it can be transformed into one}.

This is where so called \define{search problems} come into play:

\begin{definition}[Search Problem]
    A \define{search problem} is given by a relation $R\subset \binstr \times \binstr$.
    For a given \define{instance} $I\in \binstr$ the computational problem, to find a \define{solution} $s \in \binstr$, that satisfies:
    $(I, s) \in R$ or output ``No'' if no such $s$ exists.
\end{definition}
\marginnote{The ``No'' case can be encoded as some special binary string.}
Now of course we can view these search problems as decision problems by looking at the corresponding decision problem given by the language:
\begin{align*}
    \mathcal{L}_R = \{ I \in \binstr |\ \exists s \in \binstr : (I, s) \in R\}
\end{align*}
We can then ask the classical complexity questions about these search problems, i.e.~whether these search problems are in \P{}? \NP{}? whether they are
\NP-Hard?
One easily observes that search problems are always at least as hard as just deciding whether a solution exist.
This is because solving a search problem also solves the underlying decision problem.
This leads to the natural question: what if we remove the underlying decision problem?
This can be done by garanteeing that ``No'' is never a solution.
We call these problems where every instance admits a solution \define{total search problems}.
\begin{definition}[Total search problems]
    A \define{total search problem} is a search problem given by a relation $R\subset \binstr \times \binstr$, such that for every given instance $I\in
        \binstr$ there is a solution $s \in \binstr$, that satisfies: $(I, s) \in R$.
\end{definition}
The complexity class \TFNP\ as introduced in \sidecite{papadimitriou_complexity_1994} is simply the class of all total search problems that lie in \NP{}.
\marginnote{This means that \TFNP\ can be seen as an intermediate class between \P\ and \NP, containing all search problems where a solution is guaranteed to
    exist, and where one can efficiently check the feasibility of a candidate solution.}
Examples of \TFNP\ problems are:
\begin{itemize}
    \item \textsc{Factoring}, the problem of finding the prime factors of a number,
    \item \textsc{Nash}, the problem of finding a nash equilibrium in a bimatrix game,
    \item \textsc{Minimize}, the problem of finding the global minimum of a convex function.
\end{itemize}
Similarly to decision problem we can also define reduction inside \TFNP{}.
\begin{definition}[Reduction]
    For two problem $R, S \in \TFNP$, we say that $R$ \define{reduces} (many to one) to $S$ if there exist polynomial time computable functions $f : \binstr
        \rightarrow
        \binstr$ and $g : \binstr \times \binstr \rightarrow \binstr$ such that for $I, s \in \binstr$: if $(f(I), s) \in S$ then $(I, g(I, s)) \in R$.
    This means that if $s$ is a solution to an instance $f(I)$ in $S$, we can compute $g(I, s)$ a solution to an instance $I$ in $R$
\end{definition}
\marginnote[-15mm]{Saying \textit{one can reduce $R$ onto $S$} can be understood as saying \textit{if one can solve $S$ efficiently then I can solve $R$
        efficiently}.}

\section{Representation of functions and sets}[Representation of objects]

As we will see the problems we will work with, are given by questions of the form ``find an $x \in S$ such that $f(x)$ has some property''. This means that we should describe how we represent the input, that is the set $S$ and the function $f$. We start by describing how we represent sets.

\subsection{Representation of sets}[Representing sets]

In this thesis we will work with sets of the form $S = \{0, \dots, 2^n - 1\}$, which we will denote by $[2^n - 1]$. Notice that this set can be identified with the set of binary strings of length $n$. We will denote the set of binary strings of length $n$ by $\bitstr^n$. Formally the functions, and the model we will use to represent the functions will use the underlying binary strings in $\bitstr^n$. For notational convenience we will often only denote the integer $x \in [2^n - 1]$ instead of the binary string.

Similary when considering the $d$-dimensional case, we can represent the set $L = [2^n - 1]^d$, which corresponds to a $d$-dimensional lattice with side length $2^n$, as the set of binary strings of length $n \cdot d$: $\bitstr^{nd}$. Again for simplicity while the underlying functions rely on the binary strings, we will often only denote the point $(x_1, \dots, x_d) \in [2^n - 1]^d$, instead of its binary representation.

\subsection{Representation of functions}[Representing functions]

Now that we have described how we describe the sets, we can describe how we represent the functions. We will represent the functions by using so-called boolean circuits. In this section we will rely on the presentation of boolean circuits as described in \sidecite{greenlaw_chapter_1998}, and refer an interested reader to this source for a more detailed description.

On a high level a boolean circuit is a directed acyclic graph, where the nodes are called \define{gates}, and the edges are called \define{wires}. The sinks of the graphs are the output gates, and the sources are the input gates. We want to start by defining a gate formally.

\begin{definition}[Gate]
    \marginnote[-10mm]{This corresponds to the gate node, having $k$ incoming edges, and one outgoing edge.}
    A gate is a function $g : \bitstr^k \rightarrow \bitstr$, where $k$ is the number of input wires of the gate.
\end{definition}

In this thesis we will only consider the following types of gates:
\begin{itemize}
    \marginnote{Notice that we only consider gates with at most two inputs, as we can always represent a gate with $k$ inputs as a composition of gates with at most two inputs.}
    \item \textbf{AND-gate}: $g(x_1, x_2) = x_1 \land x_2$,
    \item \textbf{OR-gate}: $g(x_1, x_2) = x_1 \lor x_2$,
    \item \textbf{NOT-gate}: $g(x) = \lnot x$.
\end{itemize}

Now we can describe a boolean circuit, formally as follows:
\begin{definition}[Boolean circuit]
    A boolean circuit $C$ is a labeled finute directed acyclic graph, where each vertex has a \define{type} $\tau$, with
    \begin{align*}
        \tau(v) \in \{\text{INPUT}\} \cup \{\text{OUTPUT}\} \cup \{\text{AND}, \text{OR}, \text{NOT}\}
    \end{align*}
    and with the follwing properties:
    \begin{itemize}
        \item If $\tau(v) = \text{INPUT}$, then $v$ has no incoming edges. We call these vertices the \define{inputs gates}.
        \item If $\tau(v) = \text{OUTPUT}$, then $v$ has one incoming edge. We call these vertices the \define{output gates}.
        \item If $\tau(v) = \text{AND}$, then $v$ has two incoming edges. We call these vertices the \define{AND-gates}.
        \item If $\tau(v) = \text{OR}$, then $v$ has two incoming edges. We call these vertices the \define{OR-gates}.
        \item If $\tau(v) = \text{NOT}$, then $v$ has one incoming edge. We call these vertices the \define{NOT-gates}.
    \end{itemize}
    The inputs of $C$ are given by a tuple $(x_1, \dots, x_k)$, of distinct input gates. The output of $C$ is given by a tuple $(y_1, \dots, y_l)$ of distinct output gates.
\end{definition}

We give an example of such a boolean circuit in TODO. Of course we now want to use a boolean circuit to represent a function. In order to do this we need give a formal definition of the function computed by a boolean circuit.

\begin{definition}[Computed function of a boolean circuit]
    A boolean circuit $C$ with inputs $x_1, \dots, x_n$ and outputs $y_1, \dots, y_m$ computes a function $f : \bitstr^n \rightarrow \bitstr^m$ as follows:
    \begin{itemize}
        \item The input $x_i$ is assigned the value of the $i$-th bit of the argument to the function.
        \item Every other vertex $v$ is assigned the value of the gate $g$ of the vertex, applied to the values of the incoming edges of $v$.
        \item The $i$-th bit of the output of the function is the value of the output gate $y_i$.
    \end{itemize}
\end{definition}

In figure TODO we give an example of using a boolean circuit to compute a function. From now on all functions used in problems will be formally represented by boolean circuits.

TODO: Section on depth and complexity of functions

\section{Subclasses of \TFNP}

Because the existence of complete \FNP-Problems in \TFNP\, would imply $\NP = \coNP$, as described in \sidecite{megiddo_total_1991}.
Because this is a very unexpected outcome we cannot expect to find complete problems in \TFNP{}.
This means that we should use other tools to study the structure of \TFNP{}. \par
One of the challenges is that \TFNP\ is a so-called \define{semantic} class.
By semantic class we mean a class for which it is difficult to check if that Turing Machine defines a language in this class.
\marginnote{Examples of syntactic classes include \P\ and \NP.}
A \define{syntactic} class is a class for which it is easy to check that the accepted language of a Turing Machine indeed belongs to the class.
These terms are defined in more detail in \sidecite{papadimitriou_computational_1994}.
Hence we want to study syntactic subclasses of \TFNP.
One of the proposed methods \sidecite{papadimitriou_complexity_1994} is to categorize total search problems with respect to the existence results which allow
them to be \textit{total}. This is what leads to the complexity classes we will discuss next.

\subsection{Polynomial Local Search (\PLS)}[\PLS]

The existence results which gives rise to \PLS\ is ``\textit{every directed acyclic graph has a sink}''.
We can then construct the class \PLS\ by defining it as all problems which reduce to finding the sink of a directed acyclic graph (DAG). \par
Formally we first define the problem \Localopt\ as in \sidecite{johnson_how_1988}:

\problem{Localopt}{Two binary circuits $P, S : [2^n] \rightarrow\ [2^n]$.}{A vertex $v \in [2^n]$ such that $P(S(v)) \geq\ P(v)$.}
\marginnote[-15mm]{$S$ can be seen as a proposed successor, and $P$ as a potential. The goal is to find a local minima $v$ of the potential.}

One might ask why this is equivalent to finding the sink of a DAG\@?
The circuit $S$ defines a directed graph, which might contain cycles.
Only keeping the edge on which the potential decreases (strictly) leads to a DAG, with as sinks exactly the $v$ such that $P(S(v)) \geq\ P(v)$. Now we can
define \PLS{}:

\begin{definition}[Polynomial Local Search (\PLS)]
    The class \PLS\ is the set of all \TFNP\ problems that reduce to \Localopt.
\end{definition}

One of the reasons we think that studying very ``easy'' problems such as \PLS\ is that we strongly believe that there is no clever way of solving these
problems
without actually walking through the graph.
\marginnote[-15mm]{By ``easy'' we mean that the problem can be solved by simply walking through the graph, and checking whether every vertex is a local
    minima.}
Hence if we have a graph of exponentially large size it seems very unlikely that one can find an efficient way of solving the problem.
Hence all problems in \PLS\ can be though of as including the fundamental difficulty of no beeing able to do better than to walk along some graph.

\subsection{Polynomial Parity Argument on Directed Graphs (\PPAD)}[\PPAD]

Now we want to discuss the complexity class \PPAD, introduced by Papadimitriou as one of the first syntatic subclasses of \TFNP\
in~\sidecite{papadimitriou_complexity_1994}.
The existence result giving rise to this class is that ``\textit{If a directed graph has an unbalanced vertex, then it has at least one other unbalanced
    vertex}''.
\PPAD\ can be defined using the problem \textsc{End-of-Line} as introduced in \sidecite{daskalakis_complexity_2009}.

\problem{End-of-Line}{
Boolean circuit $S, P : \bitstr^n \rightarrow \bitstr^n$ such that $P(0^n) = 0^n \neq S(0^n)$ ($0^n$ is a source.)
}{
An $x \in \bitstr^n$ such that either:
\begin{itemize}
    \item $P(S(x)) \neq x$ ($x$ is a sink) or
    \item $S(P(x)) \neq x \neq 0^n$ ($x$ is a non non-standard source)
\end{itemize}
}
\marginnote[-20mm]{Here $S$ can be thought of giving the successor of a vertex, and $P$ as giving the predecessor of a vertex.}

\begin{figure}[ht]
    \centering
    \incfig{PPAD_Example}
    \caption[Example of an \textsc{End-of-Line} Problem]{Example of an \textsc{End-of-Line} Problem with $n=3$ (8 vertices).
        The circuit $S$ is represented by solid lines and the circuit $P$ by dashed lines.
        The solutions are the sinks $x=5$, $x=7$ and $x=1$, aswell as the sources $x=4$ and $x=6$.}
    \label{fig:ppad_example}
\end{figure}

These boolean circuits represent a directed graph with maximal in and out degree 1, by having an edge from $x$ to $y$ if and only if $S(x) = y$  and $P(y) =
    x$.
The goal is to find a sink of the graph, or another source.
\marginnote{Notice that \textsc{End-of-Line} allows cycles, and that these do not induce solutions.}
It can be shown that the general case of finding a second imbalanced vertex in a directed graph (a problem called \textsc{Imbalance}) can be reduced to
\textsc{End-of-Line} \sidecite{goldberg_hairy_2021}.
Now we can define the complexity class \PPAD\ as follows:

\begin{definition}[\PPAD]
    The class \PPAD\ is the set of all \TFNP\ problems that reduce to \textsc{End-of-Line}.
\end{definition}

\subsection{End of Potential Line (\EOPL)}[\EOPL]

Next we want to discuss the complexity class \EOPL{} as introduced in \sidecite{EOPL_introduction}.
The existence results which gives rise to \EOPL\ is that \textit{``in a directed acyclic graph, there must be at least two unbalanced vertices''}.
Similarly to \PLS\ acyclicity will be enforced using a potential.

\problem{End of Potential Line}{
Two boolean circuits $S, P : \bitstr^n \rightarrow \bitstr^n$, and a boolean circuit $V : \bitstr^n \rightarrow [2^n - 1]$, such that $0^n$ is a source, (i.e.\
$P(0^n) = 0^n \neq S(0^n)$).
}{
An $x \in \bitstr^n$ such that either:
\begin{itemize}
    \item $P(S(x)) \neq x$ ($x$ is a sink)
    \item $S(P(x)) \neq x \neq 0^n$ ($x$ is a \define{non-standard source})
    \item $S(x) \neq x$, $P(S(x)) = x$ and $V(S(x)) \leq V(x)$ (violation of the monoticity of the potential)
\end{itemize}
}
\marginnote[-50mm]{Here $S$ can be thought of giving the successor of a vertex, and $P$ as giving the predecessor of a vertex.
    $V$ can be though of as a potential which is suppose to be monotonously increasing along the line.}

\begin{figure}[ht]
    \centering
    \incfig{EOPL_Solution_Example}
    \caption[Example of an \EOPL\ Problem]{Example of an \EOPL\ Problem with $n=3$ (8 vertices).
        The circuit $S$ is represented by solid lines and the circuit $P$ by dashed lines.
        The solutions are the sink $x=7$, the violation of potential at $x=5$ and the non-standard source $x=4$.}
    \label{fig:eopl_example}
\end{figure}

$S$ and $P$ can be though of as representing a directed line.
Finding another source (a non-standard source), is a violation, as a directed line only has one source.
The potential serves a garantee of acyclicity. Now we can define the complexity class \EOPL.

\begin{definition}[\EOPL]
    The class \EOPL\ is the set of all \TFNP\ problems that reduce to \textsc{End of Potential Line}.
\end{definition}

\section{The \Tarski\ Problem}[\Tarski\ Problem]
\label{sec:tarski_problem}

Next we want to introduce the \Tarski\ Problem.
Before we do this we recall that there is a partial order on the $d$ dimensional latice ${[N]}^d$, given by $x \leq y$ iff $x_i \leq y_i$ for all $i \in \{1,
    \dots, d\}$.
The name originates from \textsc{Tarski's} fixed point Theorem as introduced in \sidecite{tarski_lattice-theoretical_1955} which we remind the reader of below:

\begin{theorem}[Tarski's fixed point Theorem]
    Let $f : {[N]}^d \rightarrow {[N]}^d$ a function on the $d$-dimentional lattice.
    If $f$ is monotonous (with respect to the previously discussed partial order), then $f$ has a fixed point, i.e.\ there is an $x \in {[N]}^d$ such that
    $f(x)=x$.
\end{theorem}
\marginnote[-20mm]{This theorem is also known as the Knaster–Tarski Theorem in the litterature.}

A proof of this theorem can be found in the previously mentionned work~\cite{tarski_lattice-theoretical_1955}.
Without surprise the \Tarski\ problem as defined in \sidecite{etessami_tarskis_2020}, is now to find such a fixed-point.
Formally we define the problem as follows:
\problem{Tarski}{A boolean circuit $f : {[N]}^d \rightarrow {[N]}^d$.}{Either:
\begin{itemize}
    \item An $x \in {[N]}^d$ such that $f(x)=x$ (fixed point) or
    \item $x, y \in {[N]}^d$ such that $x \leq y$ and $f(x) \nleq f(y)$ (violation of monoticity).
\end{itemize}
}

This is of course a total search problem, as there will always either be a fixed point, or a point violating monoticity.
We now want to summarize where \Tarski\ lies inside of \TFNP{}.
It has been shown in~\cite{etessami_tarskis_2020} that \Tarski\ lies in both \PLS\ and $\P^{\PPAD}$.
Previous work~\sidecite{buss_propositional_2012}, showed that many-to-one reductions and Turing-reduction onto \PPAD\ are equivalent.
In particular this means that $\P^{\PPAD} = \PPAD$, and that \Tarski\ also lies in \PPAD{}.

\section{Structure of \texorpdfstring{$\PLS \medcap \PPAD$}{\PLS\ and \PPAD}}[\texorpdfstring{$\PLS \medcap \PPAD$}{\PLS\ and \PPAD}]

Now that we have established that \Tarski\ lies inside $\PLS \medcap \PPAD$, we want to discuss the structure of $\PLS \medcap \PPAD$ and describe recent
advances in the study of this class.
